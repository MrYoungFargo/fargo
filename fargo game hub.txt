<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MR YOUNG FARGO GAMES HUB</title>
    <!-- Google Font: Fredoka One for a rounded, playful look -->
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <!-- Three.js library for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Tailwind CSS for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Main body styling for the background and overall layout */
        body {
            margin: 0;
            overflow-x: hidden; /* Prevent horizontal scrollbars */
            display: flex;
            flex-direction: column; /* Allow content to stack vertically */
            justify-content: flex-start; /* Align content to the top */
            align-items: center;
            min-height: 100vh;
            position: relative; /* Needed for absolute positioning of layers */

            /* Background with purple and blue colors flowing from left to right */
            background: linear-gradient(to right,
                #8A2BE2, /* Blue Violet */
                #4B0082, /* Indigo */
                #4169E1, /* Royal Blue */
                #00BFFF, /* Deep Sky Blue */
                #1E90FF, /* Dodger Blue */
                #6A5ACD  /* Slate Blue */
            );
            background-size: 200% auto; /* Make the gradient wider than the viewport */
            animation: backgroundGradientShift 15s linear infinite alternate; /* Animate background position */
        }

        /* Animation for the background gradient to shift */
        @keyframes backgroundGradientShift {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }

        /* Container for the 3D text (MR YOUNG FARGO) */
        .name-container {
            font-family: "Fredoka One", cursive; /* Rounded font */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping for smaller screens */
            gap: 1.5rem; /* Space between words */
            position: relative; /* Make it a positioning context for z-index */
            z-index: 2; /* Ensure text is above the 3D canvas */
            min-height: 100vh; /* Ensure this section takes at least full viewport height */
            padding-top: 5vh; /* Add some top padding */
            box-sizing: border-box; /* Include padding in height calculation */
        }

        /* Styling for individual words */
        .word-3d {
            font-size: 6rem; /* Bigger font size */
            font-weight: 900; /* Extra bold */
            transform-style: preserve-3d;
            transition: transform 0.4s ease-in-out; /* Smooth hover transition */
            cursor: pointer;
            position: relative;
            text-align: center; /* Center the longer text */

            /* Gradient text color that fades across the words */
            background-image: linear-gradient(to right,
                #FF0000, /* Bright Red */
                #FF8C00, /* Dark Orange */
                #FFFF00, /* Bright Yellow */
                #00FF00, /* Bright Green */
                #00FFFF, /* Bright Cyan */
                #0000FF, /* Bright Blue */
                #FF00FF  /* Bright Magenta */
            );
            background-size: 200% auto; /* Make the gradient wider than the text */
            background-position: 0% 50%; /* Start gradient from the left */
            animation: textGradientShift 8s linear infinite alternate; /* Animate text gradient position */

            -webkit-background-clip: text; /* Clip background to text shape */
            -webkit-text-fill-color: transparent; /* Make text color transparent to show background */

            /* NO text-shadow properties - as requested */
        }

        /* Animation for the text gradient to shift */
        @keyframes textGradientShift {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }

        .word-3d:hover {
            transform: translateZ(70px) rotateX(15deg) rotateY(15deg); /* Lift and rotate on hover */
        }

        /* Responsive adjustments for text */
        @media (max-width: 768px) {
            .word-3d {
                font-size: 4.5rem; /* Adjusted font size for tablets */
            }
        }

        @media (max-width: 480px) {
            .word-3d {
                font-size: 3.5rem; /* Adjusted font size for mobile */
            }
            .name-container {
                flex-direction: column; /* Stack words vertically on very small screens */
                gap: 1rem;
            }
        }

        /* Styling for the Three.js canvas */
        #threejs-canvas {
            position: fixed; /* Keep canvas fixed in background */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Ensure it's behind the text and content */
            background: transparent; /* Make sure the canvas background is transparent */
        }

        /* General styling for interactive sections */
        .interactive-section {
            position: relative; /* Ensure it's above the canvas */
            z-index: 3; /* Higher than text and canvas */
            background-color: rgba(255, 255, 255, 0.9); /* Semi-transparent white background */
            border-radius: 1.5rem; /* Rounded corners */
            padding: 2rem;
            margin-top: 5vh; /* Space from the top content */
            margin-bottom: 5vh; /* Space from the bottom */
            width: 90%; /* Responsive width */
            max-width: 800px; /* Max width for readability */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2); /* Subtle shadow */
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: "Inter", sans-serif; /* Use Inter for content text */
            color: #333;
        }

        /* Loading spinner (kept for potential future use or if AI is re-added) */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: none; /* Hidden by default */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Memory Game Specific Styles */
        .memory-game-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* 4 columns */
            grid-gap: 1rem; /* Space between cards */
            padding: 1rem;
            background-color: rgba(0, 0, 0, 0.1); /* Slightly dark background for the grid */
            border-radius: 1rem;
            max-width: 500px; /* Max width for the game board */
            width: 100%;
            margin-top: 1.5rem;
        }

        .memory-card {
            width: 100%;
            padding-bottom: 100%; /* Makes cards square */
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
            border-radius: 0.75rem; /* Rounded corners for cards */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .memory-card.flip {
            transform: rotateY(180deg);
        }

        .memory-card.match {
            opacity: 0.5; /* Fade out matched cards slightly */
            pointer-events: none; /* Disable interaction on matched cards */
        }

        .front-face, .back-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden; /* Hide the back when flipped */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem; /* Icon size */
            border-radius: 0.75rem; /* Match card border-radius */
        }

        .front-face {
            background: linear-gradient(to bottom right, #fef2f2, #fee2e2); /* Light pink/red gradient */
            color: #ef4444; /* Red icon color */
            transform: rotateY(180deg); /* Initially rotate front-face to be hidden */
        }

        .back-face {
            background: linear-gradient(to bottom right, #a78bfa, #8b5cf6); /* Purple gradient for back of card */
            color: #ffffff; /* White icon color for back */
            /* NO transform on back-face, so it's visible by default */
            font-size: 1.5rem; /* Smaller text for "Memory" */
            font-weight: bold;
        }

        /* Responsive adjustments for game cards */
        @media (max-width: 768px) {
            .front-face, .back-face {
                font-size: 2rem;
            }
        }

        @media (max-width: 480px) {
            .front-face, .back-face {
                font-size: 1.5rem;
            }
            .memory-game-grid {
                grid-template-columns: repeat(3, 1fr); /* 3 columns on smaller screens */
                grid-gap: 0.75rem;
            }
        }

        /* Games Menu Specific Styles */
        .games-menu {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /* Responsive grid for game buttons */
            gap: 1.5rem;
            width: 100%;
            margin-top: 1.5rem;
        }

        .game-button {
            background: linear-gradient(to right, #6366f1, #8b5cf6); /* Indigo to Purple gradient */
            color: white;
            font-weight: bold;
            padding: 1.5rem;
            border-radius: 1rem;
            text-align: center;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            font-size: 1.25rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 120px; /* Ensure consistent button height */
        }

        .game-button:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .game-button span {
            font-size: 3rem; /* Icon size within button */
            margin-bottom: 0.5rem;
        }

        /* Game Display Area */
        #gameDisplayArea {
            min-height: 400px; /* Ensure enough space for game content */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
        }

        /* Tic-Tac-Toe Specific Styles */
        .tic-tac-toe-grid {
            display: grid;
            grid-template-columns: repeat(3, 80px);
            grid-template-rows: repeat(3, 80px);
            gap: 5px;
            background-color: #333;
            border: 5px solid #333;
            border-radius: 8px;
            margin-top: 1.5rem;
        }

        .tic-tac-toe-cell {
            width: 80px;
            height: 80px;
            background-color: #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .tic-tac-toe-cell:hover {
            background-color: #ddd;
        }

        .tic-tac-toe-cell.x {
            color: #ef4444; /* Red */
        }

        .tic-tac-toe-cell.o {
            color: #3b82f6; /* Blue */
        }
    </style>
</head>
<body>
    <!-- This is the Three.js canvas where 3D objects will be rendered -->
    <canvas id="threejs-canvas"></canvas>

    <!-- This is your existing MR YOUNG FARGO text -->
    <div class="name-container">
        <div class="word-3d">MR YOUNG FARGO GAMES HUB</div>
    </div>

    <!-- Games Hub Section -->
    <section class="interactive-section mt-10">
        <h2 class="text-4xl font-bold text-center mb-6 text-blue-700">Games Hub!</h2>
        <p class="text-lg text-center mb-4">
            Choose a game to play!
        </p>

        <div class="games-menu">
            <button class="game-button" data-game="memory">
                <span>🧠</span> Memory Game
            </button>
            <button class="game-button" data-game="tic-tac-toe">
                <span>❌⭕</span> Tic-Tac-Toe
            </button>
            <button class="game-button" data-game="quiz">
                <span>❓</span> Simple Quiz
            </button>
        </div>

        <div id="gameDisplayArea" class="w-full mt-8 p-6 bg-gray-100 border border-gray-200 rounded-lg text-gray-800 leading-relaxed whitespace-pre-wrap">
            <p class="text-xl text-gray-600">Select a game from the menu above to start playing!</p>
        </div>

        <!-- Memory Game content (hidden by default, shown when selected) -->
        <div id="memoryGameContent" class="w-full" style="display: none;">
            <div class="flex flex-col sm:flex-row justify-center items-center gap-4 mb-6 w-full">
                <div class="text-xl font-semibold">Time: <span id="gameTime">0s</span></div>
                <div class="text-xl font-semibold">Moves: <span id="gameMoves">0</span></div>
                <button id="resetMemoryGameBtn"
                        class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-full transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50">
                    Reset Game
                </button>
            </div>
            <div class="memory-game-grid" id="memoryGameGrid">
                <!-- Cards will be inserted here by JavaScript -->
            </div>
            <div id="memoryGameMessage" class="text-2xl font-bold mt-6 text-center text-green-600" style="display: none;">
                You won! Congratulations!
            </div>
        </div>

        <!-- Tic-Tac-Toe Game content (hidden by default) -->
        <div id="ticTacToeGameContent" class="w-full" style="display: none;">
            <h3 class="text-3xl font-bold mb-4 text-center text-green-700">Tic-Tac-Toe!</h3>
            <p id="ticTacToeStatus" class="text-xl font-semibold text-center mb-4">Player X's Turn</p>
            <div class="tic-tac-toe-grid" id="ticTacToeGrid">
                <div class="tic-tac-toe-cell" data-cell-index="0"></div>
                <div class="tic-tac-toe-cell" data-cell-index="1"></div>
                <div class="tic-tac-toe-cell" data-cell-index="2"></div>
                <div class="tic-tac-toe-cell" data-cell-index="3"></div>
                <div class="tic-tac-toe-cell" data-cell-index="4"></div>
                <div class="tic-tac-toe-cell" data-cell-index="5"></div>
                <div class="tic-tac-toe-cell" data-cell-index="6"></div>
                <div class="tic-tac-toe-cell" data-cell-index="7"></div>
                <div class="tic-tac-toe-cell" data-cell-index="8"></div>
            </div>
            <button id="resetTicTacToeBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-full transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 mt-6">
                Reset Game
            </button>
        </div>

        <!-- Simple Quiz Game content (hidden by default) -->
        <div id="quizGameContent" class="w-full" style="display: none;">
            <h3 class="text-3xl font-bold mb-4 text-center text-orange-700">Simple Quiz!</h3>
            <div id="quizQuestion" class="text-xl font-semibold text-center mb-6"></div>
            <div id="quizOptions" class="flex flex-col gap-3 w-full max-w-sm">
                <!-- Options will be inserted here -->
            </div>
            <button id="nextQuizBtn" class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-3 px-8 rounded-full transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:ring-opacity-50 mt-6" style="display: none;">
                Next Question
            </button>
            <div id="quizResult" class="text-2xl font-bold mt-6 text-center" style="display: none;"></div>
            <button id="resetQuizBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-full transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-50 mt-4" style="display: none;">
                Play Again
            </button>
        </div>

    </section>


    <script>
        // --- Three.js Setup (existing code) ---
        let scene, camera, renderer, objectGroup;
        let mouseX = 0, mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;

        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(
                75, // Field of view
                window.innerWidth / window.innerHeight, // Aspect ratio
                0.1, // Near clipping plane
                1000 // Far clipping plane
            );
            camera.position.z = 10; // Position camera back to see objects

            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('threejs-canvas'), // Use the specific canvas element
                alpha: true, // Enable transparency for the canvas background
                antialias: true // Smooth edges
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // For sharper rendering on high-DPI screens

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Soft white light
            scene.add(ambientLight);

            // Added a PointLight for more dynamic lighting and highlights
            const pointLight = new THREE.PointLight(0xffffff, 1.5, 100); // Color, intensity, distance
            pointLight.position.set(0, 0, 20); // Position it in front of the objects
            scene.add(pointLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Brighter light from a direction
            directionalLight.position.set(0, 1, 1).normalize();
            scene.add(directionalLight);

            // Group to hold all objects for easier rotation
            objectGroup = new THREE.Group();
            scene.add(objectGroup);

            // Define different colors for each object
            const colors = [
                0xFF0000, // Red
                0x00FF00, // Green
                0x0000FF, // Blue
                0xFFFF00, // Yellow
                0xFF00FF  // Magenta
            ];

            // Create an environment map for reflections
            const cubeTextureLoader = new THREE.CubeTextureLoader();
            const environmentMap = cubeTextureLoader.load([
                'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=', // px (placeholder for now)
                'data:image/png;base64,iVBORw0KGgoAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=', // nx
                'data:image/png;base66,iVBORw0KGgoAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=', // py
                'data:image/png;base64,iVBORw0KGgoAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=', // ny
                'data:image/png;base64,iVBORw0KGgoAAAABJRU5ErkJggg==', // pz
                'data:image/png;base64,iVBORw0KGgoAAAABJRU5ErkJggg=='  // nz
            ]);

            // The material now uses MeshStandardMaterial for PBR, with roughness, metalness, and envMap
            const createRealisticMaterial = (color) => {
                return new THREE.MeshStandardMaterial({
                    color: color,
                    metalness: 0.8,   // How metallic the surface is. 0.0 to 1.0.
                    roughness: 0.2,   // How rough the surface is. 0.0 to 1.0.
                    envMap: environmentMap, // Apply the environment map for reflections
                    envMapIntensity: 1 // How strong the environment map reflections are
                });
            };


            // Sphere - Made even larger, now with a distinct color and realistic material
            const sphereGeometry = new THREE.SphereGeometry(25, 32, 32);
            const sphere = new THREE.Mesh(sphereGeometry, createRealisticMaterial(colors[0]));
            sphere.position.set(-60, -30, -90);
            objectGroup.add(sphere);

            // Torus - Made even larger, now with a distinct color and realistic material
            const torusGeometry = new THREE.TorusGeometry(30, 8, 16, 100);
            const torus = new THREE.Mesh(torusGeometry, createRealisticMaterial(colors[1]));
            torus.position.set(60, 35, -95);
            objectGroup.add(torus);

            // Icosahedron - Made even larger, now with a distinct color and realistic material
            const icosahedronGeometry = new THREE.IcosahedronGeometry(28);
            const icosahedron = new THREE.Mesh(icosahedronGeometry, createRealisticMaterial(colors[2]));
            icosahedron.position.set(0, -45, -88);
            objectGroup.add(icosahedron);

            // Cone - Made even larger, now with a distinct color and realistic material
            const coneGeometry = new THREE.ConeGeometry(25, 50, 32);
            const cone = new THREE.Mesh(coneGeometry, createRealisticMaterial(colors[3]));
            cone.position.set(-65, 40, -100);
            objectGroup.add(cone);

            // Dodecahedron - Made even larger, now with a distinct color and realistic material
            const dodecahedronGeometry = new THREE.DodecahedronGeometry(26);
            const dodecahedron = new THREE.Mesh(dodecahedronGeometry, createRealisticMaterial(colors[4]));
            dodecahedron.position.set(65, -40, -97);
            objectGroup.add(dodecahedron);


            // Event Listeners for responsiveness and mouse interaction
            window.addEventListener('resize', onWindowResizeThreeJS, false);
            document.addEventListener('mousemove', onDocumentMouseMoveThreeJS, false);
            document.addEventListener('mousedown', onDocumentMouseDownThreeJS, false);
            document.addEventListener('mouseup', onDocumentMouseUpThreeJS, false);
            document.addEventListener('mouseleave', onDocumentMouseUpThreeJS, false); // Stop dragging if mouse leaves window
        }

        // Handle window resizing for Three.js
        function onWindowResizeThreeJS() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Mouse interaction variables for Three.js
        let isDraggingThreeJS = false;
        let previousMouseXThreeJS = 0;
        let previousMouseYThreeJS = 0;

        function onDocumentMouseDownThreeJS(event) {
            isDraggingThreeJS = true;
            previousMouseXThreeJS = event.clientX;
            previousMouseYThreeJS = event.clientY;
        }

        function onDocumentMouseUpThreeJS(event) {
            isDraggingThreeJS = false;
        }

        function onDocumentMouseMoveThreeJS(event) {
            if (!isDraggingThreeJS) return;

            const deltaX = event.clientX - previousMouseXThreeJS;
            const deltaY = event.clientY - previousMouseYThreeJS;

            // Rotate the group of objects based on mouse movement
            objectGroup.rotation.y += deltaX * 0.005;
            objectGroup.rotation.x += deltaY * 0.005;

            previousMouseXThreeJS = event.clientX;
            previousMouseYThreeJS = event.clientY;
        }

        // Animation loop for Three.js
        function animateThreeJS() {
            requestAnimationFrame(animateThreeJS);

            // Rotate objects within the group for a subtle dynamic feel
            objectGroup.children.forEach(obj => {
                obj.rotation.x += 0.002;
                obj.rotation.y += 0.002;
            });

            renderer.render(scene, camera);
        }

        // Start the Three.js scene when the window loads
        window.onload = function () {
            initThreeJS();
            animateThreeJS();
        };

        // --- Game Management Logic ---
        document.addEventListener('DOMContentLoaded', () => {
            const gameButtons = document.querySelectorAll('.game-button');
            const gameDisplayArea = document.getElementById('gameDisplayArea');
            const memoryGameContent = document.getElementById('memoryGameContent');
            const ticTacToeGameContent = document.getElementById('ticTacToeGameContent');
            const quizGameContent = document.getElementById('quizGameContent');


            // Function to show a specific game
            function showGame(gameId) {
                // Hide all game content areas first
                gameDisplayArea.style.display = 'none';
                memoryGameContent.style.display = 'none';
                ticTacToeGameContent.style.display = 'none';
                quizGameContent.style.display = 'none';


                // Show the selected game content and initialize it
                if (gameId === 'memory') {
                    memoryGameContent.style.display = 'block';
                    initializeMemoryGame(); // Renamed to avoid conflict
                } else if (gameId === 'tic-tac-toe') {
                    ticTacToeGameContent.style.display = 'flex';
                    initializeTicTacToeGame();
                } else if (gameId === 'quiz') {
                    quizGameContent.style.display = 'flex';
                    initializeQuizGame();
                } else if (gameId === 'initial') {
                    gameDisplayArea.style.display = 'flex'; // Show initial message
                }
            }

            // Event listeners for game buttons
            gameButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const gameId = button.dataset.game;
                    showGame(gameId);
                });
            });

            // --- Memory Game Specific Logic ---
            const memoryGameGrid = document.getElementById('memoryGameGrid');
            const memoryGameTimeSpan = document.getElementById('gameTime');
            const memoryGameMovesSpan = document.getElementById('gameMoves');
            const resetMemoryGameBtn = document.getElementById('resetMemoryGameBtn');
            const memoryGameMessage = document.getElementById('memoryGameMessage');

            const memoryCardIcons = ['⭐', '🚀', '💡', '🌈', '⚡', '🤖', '👾', '👽']; // 8 unique icons
            let memoryCards = [];
            let memoryFlippedCards = [];
            let memoryMatchedPairs = 0;
            let memoryMoves = 0;
            let memoryTimer = 0;
            let memoryTimerInterval;
            let memoryLockBoard = false; // To prevent flipping more than two cards at a time

            function initializeMemoryGame() {
                // Duplicate icons to create pairs
                memoryCards = [...memoryCardIcons, ...memoryCardIcons];
                shuffleCards(memoryCards);

                memoryGameGrid.innerHTML = ''; // Clear existing cards
                memoryCards.forEach((icon, index) => {
                    const cardElement = document.createElement('div');
                    cardElement.classList.add('memory-card');
                    cardElement.dataset.icon = icon;
                    cardElement.dataset.index = index; // Store original index for tracking

                    cardElement.innerHTML = `
                        <div class="front-face">${icon}</div>
                        <div class="back-face">Memory</div>
                    `;
                    cardElement.addEventListener('click', flipMemoryCard);
                    memoryGameGrid.appendChild(cardElement);
                });

                resetMemoryGameStats();
                startMemoryGameTimer();
                memoryGameMessage.style.display = 'none'; // Hide win message
            }

            function shuffleCards(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]]; // Swap elements
                }
            }

            function flipMemoryCard() {
                if (memoryLockBoard) return; // Prevent flipping if board is locked
                if (this === memoryFlippedCards[0]) return; // Prevent double clicking the same card

                this.classList.add('flip');
                memoryFlippedCards.push(this);

                if (memoryFlippedCards.length === 2) {
                    memoryMoves++;
                    memoryGameMovesSpan.textContent = memoryMoves;
                    checkForMemoryMatch();
                }
            }

            function checkForMemoryMatch() {
                const [card1, card2] = memoryFlippedCards;
                const isMatch = card1.dataset.icon === card2.dataset.icon;

                if (isMatch) {
                    memoryMatchedPairs++;
                    disableMemoryCards();
                    if (memoryMatchedPairs === memoryCardIcons.length) { // All pairs matched
                        clearInterval(memoryTimerInterval);
                        memoryGameMessage.textContent = `You won in ${memoryMoves} moves and ${memoryTimer} seconds!`;
                        memoryGameMessage.style.display = 'block';
                    }
                } else {
                    unflipMemoryCards();
                }
            }

            function disableMemoryCards() {
                memoryFlippedCards[0].removeEventListener('click', flipMemoryCard);
                memoryFlippedCards[1].removeEventListener('click', flipMemoryCard);
                memoryFlippedCards[0].classList.add('match'); // Add match class for styling
                memoryFlippedCards[1].classList.add('match');
                resetMemoryFlippedCards();
            }

            function unflipMemoryCards() {
                memoryLockBoard = true; // Lock the board
                setTimeout(() => {
                    memoryFlippedCards[0].classList.remove('flip');
                    memoryFlippedCards[1].classList.remove('flip');
                    resetMemoryFlippedCards();
                    memoryLockBoard = false; // Unlock the board
                }, 1000); // Wait 1 second before unflipping
            }

            function resetMemoryFlippedCards() {
                memoryFlippedCards = [];
            }

            function resetMemoryGameStats() {
                memoryMatchedPairs = 0;
                memoryMoves = 0;
                memoryTimer = 0;
                memoryGameMovesSpan.textContent = memoryMoves;
                memoryGameTimeSpan.textContent = memoryTimer + 's';
                clearInterval(memoryTimerInterval); // Clear any running timer
            }

            function startMemoryGameTimer() {
                clearInterval(memoryTimerInterval); // Ensure only one timer runs
                memoryTimerInterval = setInterval(() => {
                    memoryTimer++;
                    memoryGameTimeSpan.textContent = memoryTimer + 's';
                }, 1000);
            }

            resetMemoryGameBtn.addEventListener('click', initializeMemoryGame);


            // --- Tic-Tac-Toe Game Logic ---
            const ticTacToeGrid = document.getElementById('ticTacToeGrid');
            const ticTacToeCells = document.querySelectorAll('.tic-tac-toe-cell');
            const ticTacToeStatus = document.getElementById('ticTacToeStatus');
            const resetTicTacToeBtn = document.getElementById('resetTicTacToeBtn');

            let ticTacToeBoard;
            let currentPlayer;
            let gameActive;

            const winningConditions = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
                [0, 4, 8], [2, 4, 6]             // Diagonals
            ];

            function initializeTicTacToeGame() {
                ticTacToeBoard = ['', '', '', '', '', '', '', '', ''];
                currentPlayer = 'X';
                gameActive = true;
                ticTacToeStatus.textContent = `Player ${currentPlayer}'s Turn`;
                ticTacToeCells.forEach(cell => {
                    cell.textContent = '';
                    cell.classList.remove('x', 'o');
                    // Remove existing event listener before re-adding with { once: true }
                    cell.removeEventListener('click', handleTicTacToeCellClick);
                    cell.addEventListener('click', handleTicTacToeCellClick, { once: true }); // Ensure click only happens once per cell
                });
            }

            function handleTicTacToeCellClick(event) {
                const clickedCell = event.target;
                const clickedCellIndex = parseInt(clickedCell.dataset.cellIndex);

                if (ticTacToeBoard[clickedCellIndex] !== '' || !gameActive) {
                    return;
                }

                ticTacToeBoard[clickedCellIndex] = currentPlayer;
                clickedCell.textContent = currentPlayer;
                clickedCell.classList.add(currentPlayer.toLowerCase());

                checkTicTacToeResult();
            }

            function checkTicTacToeResult() {
                let roundWon = false;
                for (let i = 0; i < winningConditions.length; i++) {
                    const winCondition = winningConditions[i];
                    let a = ticTacToeBoard[winCondition[0]];
                    let b = ticTacToeBoard[winCondition[1]];
                    let c = ticTacToeBoard[winCondition[2]];

                    if (a === '' || b === '' || c === '') {
                        continue;
                    }
                    if (a === b && b === c) {
                        roundWon = true;
                        break;
                    }
                }

                if (roundWon) {
                    ticTacToeStatus.textContent = `Player ${currentPlayer} Wins!`;
                    gameActive = false;
                    return;
                }

                let roundDraw = !ticTacToeBoard.includes('');
                if (roundDraw) {
                    ticTacToeStatus.textContent = `It's a Draw!`;
                    gameActive = false;
                    return;
                }

                currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                ticTacToeStatus.textContent = `Player ${currentPlayer}'s Turn`;
            }

            resetTicTacToeBtn.addEventListener('click', initializeTicTacToeGame);


            // --- Simple Quiz Game Logic ---
            const quizQuestionDiv = document.getElementById('quizQuestion');
            const quizOptionsDiv = document.getElementById('quizOptions');
            const nextQuizBtn = document.getElementById('nextQuizBtn');
            const quizResultDiv = document.getElementById('quizResult');
            const resetQuizBtn = document.getElementById('resetQuizBtn');

            let currentQuizQuestionIndex = 0;
            let score = 0;
            let quizQuestions = [
                {
                    question: "What is the capital of France?",
                    options: ["Berlin", "Madrid", "Paris", "Rome"],
                    answer: "Paris"
                },
                {
                    question: "Which planet is known as the Red Planet?",
                    options: ["Earth", "Mars", "Jupiter", "Venus"],
                    answer: "Mars"
                },
                {
                    question: "What is 7 + 8?",
                    options: ["12", "13", "14", "15"],
                    answer: "15"
                },
                {
                    question: "What is the largest ocean on Earth?",
                    options: ["Atlantic", "Indian", "Arctic", "Pacific"],
                    answer: "Pacific"
                },
                {
                    question: "Who painted the Mona Lisa?",
                    options: ["Vincent van Gogh", "Pablo Picasso", "Leonardo da Vinci", "Claude Monet"],
                    answer: "Leonardo da Vinci"
                }
            ];

            function initializeQuizGame() {
                currentQuizQuestionIndex = 0;
                score = 0;
                quizResultDiv.style.display = 'none';
                resetQuizBtn.style.display = 'none';
                nextQuizBtn.style.display = 'inline-block';
                loadQuizQuestion();
            }

            function loadQuizQuestion() {
                if (currentQuizQuestionIndex < quizQuestions.length) {
                    const questionData = quizQuestions[currentQuizQuestionIndex];
                    quizQuestionDiv.textContent = questionData.question;
                    quizOptionsDiv.innerHTML = ''; // Clear previous options

                    questionData.options.forEach(option => {
                        const button = document.createElement('button');
                        button.classList.add('bg-blue-200', 'hover:bg-blue-300', 'text-blue-800', 'font-semibold', 'py-2', 'px-4', 'rounded-lg', 'transition', 'duration-200');
                        button.textContent = option;
                        button.dataset.option = option;
                        button.addEventListener('click', selectQuizOption);
                        quizOptionsDiv.appendChild(button);
                    });
                    quizResultDiv.textContent = ''; // Clear result message for new question
                } else {
                    showQuizResult();
                }
            }

            function selectQuizOption(event) {
                const selectedOption = event.target.dataset.option;
                const correctAnswer = quizQuestions[currentQuizQuestionIndex].answer;

                // Disable all options after selection
                Array.from(quizOptionsDiv.children).forEach(button => {
                    button.disabled = true;
                    if (button.dataset.option === correctAnswer) {
                        button.classList.remove('bg-blue-200', 'hover:bg-blue-300');
                        button.classList.add('bg-green-400', 'text-green-900'); // Highlight correct answer
                    } else if (button.dataset.option === selectedOption) {
                        button.classList.remove('bg-blue-200', 'hover:bg-blue-300');
                        button.classList.add('bg-red-400', 'text-red-900'); // Highlight incorrect selection
                    }
                });

                if (selectedOption === correctAnswer) {
                    score++;
                }
                nextQuizBtn.style.display = 'inline-block'; // Show next button
            }

            function showQuizResult() {
                quizQuestionDiv.textContent = '';
                quizOptionsDiv.innerHTML = '';
                nextQuizBtn.style.display = 'none';
                quizResultDiv.style.display = 'block';
                quizResultDiv.textContent = `Quiz Complete! You scored ${score} out of ${quizQuestions.length}.`;
                quizResultDiv.classList.remove('text-green-600', 'text-red-600');
                if (score === quizQuestions.length) {
                    quizResultDiv.classList.add('text-green-600');
                } else if (score > quizQuestions.length / 2) {
                    quizResultDiv.classList.add('text-blue-600');
                } else {
                    quizResultDiv.classList.add('text-red-600');
                }
                resetQuizBtn.style.display = 'inline-block';
            }

            nextQuizBtn.addEventListener('click', () => {
                currentQuizQuestionIndex++;
                loadQuizQuestion();
            });

            resetQuizBtn.addEventListener('click', initializeQuizGame);


            // Initial game setup when the page loads
            showGame('initial');
        });
    </script>
</body>
</html>
